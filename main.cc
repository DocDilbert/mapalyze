#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <iterator>
#include <algorithm>
#include <cxxopts.hpp>
#include <string>
#include <fstream>
#include <streambuf>
#include <boost/algorithm/string/predicate.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>

using namespace std;

struct MapSection
{
  uint32_t begin_adr;
  uint32_t end_adr;
  std::string object_name;

  uint32_t GetSize() const
  {
    return end_adr - begin_adr + 1;
  }

  friend ostream &operator<<(ostream &os, const MapSection &msec);
};

ostream &operator<<(ostream &os, const MapSection &msec)
{
  os << "0x" << hex << uppercase << setw(8) << msec.begin_adr << " |"
     << "0x" << hex << uppercase << setw(8) << msec.end_adr
     << " |" << dec << setw(8) << msec.GetSize() << " | " << msec.object_name;
  return os;
}

std::string get_file_contents(const char *filename)
{
  std::ifstream in(filename, std::ios::in | std::ios::binary);
  if (in)
  {
    std::string contents;
    in.seekg(0, std::ios::end);
    contents.resize(in.tellg());
    in.seekg(0, std::ios::beg);
    in.read(&contents[0], contents.size());
    in.close();
    return (contents);
  }
  throw(errno);
}

std::vector<std::string>
split(std::string const &original, char separator)
{
  std::vector<std::string> results;
  std::string::const_iterator start = original.begin();
  std::string::const_iterator end = original.end();
  std::string::const_iterator next = std::find(start, end, separator);
  while (next != end)
  {
    results.push_back(std::string(start, next));
    start = next + 1;
    auto next_char = start + 1;
    next = std::find(start, end, separator);

    while (next == next_char)
    {
      start = next + 1;
      next_char = start + 1;
      next = std::find(start, end, separator);
    }
  }
  results.push_back(std::string(start, next));
  return results;
}
bool is_space( char c ) 
{
  return c==' ';
}

MapSection parse_entry(string const &entry)
{
  vector<string> container;
  //container.reserve(5);
 
  auto splitted = boost::split(container, entry, is_space, boost::token_compress_on);
  if (splitted.size() <= 3)
  {
    throw "No enough elements";
  }

  if (!boost::starts_with(splitted[1], "0x"))
  {
    throw "First element is not a hex value";
  };

  std::size_t processed = 0;
  auto address = std::stoul(splitted[1].substr(2, string::npos), &processed, 16);

  if (!boost::starts_with(splitted[2], "0x"))
  {
    throw "Second element is not a hex value";
  };

  auto size = std::stoul(splitted[2].substr(2, string::npos), &processed, 16);

  MapSection sec = {
      .begin_adr = static_cast<uint32_t>(address),
      .end_adr = static_cast<uint32_t>(address) + static_cast<uint32_t>(size) - 1,
      .object_name = splitted[3]};

  return sec;
}

vector<MapSection> parse_lines(string const &str)
{
  const char separator = '\n';
  std::string::const_iterator start = str.begin();
  std::string::const_iterator end = str.end();
  std::string::const_iterator next = std::find(start, end, separator);
  vector<MapSection> list;


  while (next != end)
  {
    try
    {
      auto sec = parse_entry(std::string(start, next));
      list.push_back(sec);
    }
    catch (...)
    {
    }
    
    start = next + 1;
    next = std::find(start, end, separator);
  }

  return list;
}

int main(int argc, char *argv[])
{
  cxxopts::Options options("mapalyze", "A tool to analyze map files generated by gcc.");
  options
      .positional_help("[file.map]");
  options.add_options()("f,file", "Name of the map file", cxxopts::value<std::string>())("h,help", "Print usage")("filename", "Name of the map file", cxxopts::value<std::string>());
  options.parse_positional("filename");
  auto result = options.parse(argc, argv);

  if (result.count("help"))
  {
    std::cout << options.help() << std::endl;
    exit(0);
  }

  if (!result.count("filename"))
  {
    std::cout << "ERROR: filename must be specified." << std::endl
              << std::endl;
    ;
    std::cout << options.help() << std::endl;
    exit(-1);
  }

  auto &filename = result["filename"].as<std::string>();

  cout<<"Read file..."<<endl;
  std::string str = get_file_contents(filename.c_str());

  // find sections
  auto mem_cfg_pos = str.find("Memory Configuration", 0);
  auto linker_pos = str.find("Linker script and memory map", mem_cfg_pos);
  auto output_pos = str.find("OUTPUT(", linker_pos);

  cout<<"Extract..."<<endl;
  auto mem_cfg = str.substr(mem_cfg_pos, linker_pos - mem_cfg_pos);
  auto linkage = str.substr(linker_pos, output_pos - linker_pos);

  cout<<"Parse..."<<endl;
  auto sections = parse_lines(linkage);

  cout<<"Iterate..."<<endl;
  for (auto s : sections)
  {
    cout << s << endl;
  }
  //auto contents = split(str, '\n');
  //std::cout << contents.size() << std::endl;
  return 0;
}
